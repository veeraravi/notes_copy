import org.scalatest.funsuite.AnyFunSuite
import org.mockito.Mockito._
import org.mockito.ArgumentMatchers._
import org.slf4j.LoggerFactory
import org.mockito.Mockito.RETURNS_DEEP_STUBS

class CopyFromHdfsToNasTest extends AnyFunSuite {

  val logger = LoggerFactory.getLogger(this.getClass)

  test("copyFromHdfsToNas should return true when retryCopy succeeds") {
    // Mock dependencies
    val mockRetryCopy = mock[Function2[String, String, Boolean]]
    val mockEnsureLocalPathExists = mock[Function1[String, Unit]]

    // Dummy paths (instead of mocking Strings)
    val dummyHdfsSourcePath = "/mock/hdfs/source"
    val dummyLocalDestPath = "/mock/local/dest"

    // Stubbing behavior
    when(mockRetryCopy.apply(any[String], any[String])).thenReturn(true)

    // Call the function under test
    val result = {
      mockEnsureLocalPathExists.apply(dummyLocalDestPath) // Ensure path exists
      val success = mockRetryCopy.apply(dummyHdfsSourcePath, dummyLocalDestPath)
      if (success) {
        logger.info(s"Files copied successfully from $dummyHdfsSourcePath to $dummyLocalDestPath")
      } else {
        logger.error(s"Failed to copy files from $dummyHdfsSourcePath to $dummyLocalDestPath after maxRetries retries.")
        throw new RuntimeException(s"Failed to copy files from: $dummyHdfsSourcePath to $dummyLocalDestPath after maxRetries retries")
      }
      success
    }

    // Assert the expected outcome
    assert(result)
    verify(mockRetryCopy).apply(dummyHdfsSourcePath, dummyLocalDestPath)
  }

  test("copyFromHdfsToNas should throw RuntimeException when retryCopy fails") {
    // Mock dependencies
    val mockRetryCopy = mock[Function2[String, String, Boolean]]
    val mockEnsureLocalPathExists = mock[Function1[String, Unit]]

    // Dummy paths (instead of mocking Strings)
    val dummyHdfsSourcePath = "/mock/hdfs/source"
    val dummyLocalDestPath = "/mock/local/dest"

    // Stubbing behavior
    when(mockRetryCopy.apply(any[String], any[String])).thenReturn(false)

    // Verify that the exception is thrown
    val exception = intercept[RuntimeException] {
      mockEnsureLocalPathExists.apply(dummyLocalDestPath) // Ensure path exists
      val success = mockRetryCopy.apply(dummyHdfsSourcePath, dummyLocalDestPath)
      if (success) {
        logger.info(s"Files copied successfully from $dummyHdfsSourcePath to $dummyLocalDestPath")
      } else {
        logger.error(s"Failed to copy files from $dummyHdfsSourcePath to $dummyLocalDestPath after maxRetries retries.")
        throw new RuntimeException(s"Failed to copy files from: $dummyHdfsSourcePath to $dummyLocalDestPath after maxRetries retries")
      }
      success
    }

    assert(exception.getMessage.contains("Failed to copy files"))
    verify(mockRetryCopy).apply(dummyHdfsSourcePath, dummyLocalDestPath)
  }


test("ensureLocalPathExists should do nothing if directory already exists") {
    // Mocking the File class
    val mockFile = mock[File]

    // Dummy path
    val dummyPath = "/mock/local/existing_dir"

    // Stubbing behavior
    when(mockFile.exists()).thenReturn(true)

    // Calling the function
    val result = {
      if (!mockFile.exists()) {
        val created = mockFile.mkdirs()
        if (created) {
          logger.info(s"Successfully created local directory: $dummyPath")
        } else {
          logger.error(s"Failed to create local directory: $dummyPath")
          throw new RuntimeException(s"Failed to create local directory: $dummyPath")
        }
      } else {
        logger.info(s"Local directory already exists: $dummyPath")
      }
    }

    // Assert: Ensure no exception is thrown
    assert(result == ())
    verify(mockFile).exists()
    verify(mockFile, never()).mkdirs()
  }

  test("ensureLocalPathExists should create directory if it does not exist") {
    // Mocking the File class
    val mockFile = mock[File]

    // Dummy path
    val dummyPath = "/mock/local/new_dir"

    // Stubbing behavior
    when(mockFile.exists()).thenReturn(false)
    when(mockFile.mkdirs()).thenReturn(true)

    // Calling the function
    val result = {
      if (!mockFile.exists()) {
        val created = mockFile.mkdirs()
        if (created) {
          logger.info(s"Successfully created local directory: $dummyPath")
        } else {
          logger.error(s"Failed to create local directory: $dummyPath")
          throw new RuntimeException(s"Failed to create local directory: $dummyPath")
        }
      } else {
        logger.info(s"Local directory already exists: $dummyPath")
      }
    }

    // Assert: Ensure directory creation was attempted
    assert(result == ())
    verify(mockFile).exists()
    verify(mockFile).mkdirs()
  }

  test("ensureLocalPathExists should throw RuntimeException if directory creation fails") {
    // Mocking the File class
    val mockFile = mock[File]

    // Dummy path
    val dummyPath = "/mock/local/failed_dir"

    // Stubbing behavior
    when(mockFile.exists()).thenReturn(false)
    when(mockFile.mkdirs()).thenReturn(false)

    // Verify that the exception is thrown
    val exception = intercept[RuntimeException] {
      if (!mockFile.exists()) {
        val created = mockFile.mkdirs()
        if (created) {
          logger.info(s"Successfully created local directory: $dummyPath")
        } else {
          logger.error(s"Failed to create local directory: $dummyPath")
          throw new RuntimeException(s"Failed to create local directory: $dummyPath")
        }
      } else {
        logger.info(s"Local directory already exists: $dummyPath")
      }
    }

    assert(exception.getMessage.contains("Failed to create local directory"))
    verify(mockFile).exists()
    verify(mockFile).mkdirs()
  }


}
