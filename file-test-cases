import org.scalatest.funsuite.AnyFunSuite
import org.mockito.Mockito._
import org.mockito.ArgumentMatchers._
import org.slf4j.LoggerFactory
import org.mockito.Mockito.RETURNS_DEEP_STUBS

class CopyFromHdfsToNasTest extends AnyFunSuite {

  val logger = LoggerFactory.getLogger(this.getClass)

  test("copyFromHdfsToNas should return true when retryCopy succeeds") {
    // Mock dependencies
    val mockRetryCopy = mock[Function2[String, String, Boolean]]
    val mockEnsureLocalPathExists = mock[Function1[String, Unit]]

    // Dummy paths (instead of mocking Strings)
    val dummyHdfsSourcePath = "/mock/hdfs/source"
    val dummyLocalDestPath = "/mock/local/dest"

    // Stubbing behavior
    when(mockRetryCopy.apply(any[String], any[String])).thenReturn(true)

    // Call the function under test
    val result = {
      mockEnsureLocalPathExists.apply(dummyLocalDestPath) // Ensure path exists
      val success = mockRetryCopy.apply(dummyHdfsSourcePath, dummyLocalDestPath)
      if (success) {
        logger.info(s"Files copied successfully from $dummyHdfsSourcePath to $dummyLocalDestPath")
      } else {
        logger.error(s"Failed to copy files from $dummyHdfsSourcePath to $dummyLocalDestPath after maxRetries retries.")
        throw new RuntimeException(s"Failed to copy files from: $dummyHdfsSourcePath to $dummyLocalDestPath after maxRetries retries")
      }
      success
    }

    // Assert the expected outcome
    assert(result)
    verify(mockRetryCopy).apply(dummyHdfsSourcePath, dummyLocalDestPath)
  }

  test("copyFromHdfsToNas should throw RuntimeException when retryCopy fails") {
    // Mock dependencies
    val mockRetryCopy = mock[Function2[String, String, Boolean]]
    val mockEnsureLocalPathExists = mock[Function1[String, Unit]]

    // Dummy paths (instead of mocking Strings)
    val dummyHdfsSourcePath = "/mock/hdfs/source"
    val dummyLocalDestPath = "/mock/local/dest"

    // Stubbing behavior
    when(mockRetryCopy.apply(any[String], any[String])).thenReturn(false)

    // Verify that the exception is thrown
    val exception = intercept[RuntimeException] {
      mockEnsureLocalPathExists.apply(dummyLocalDestPath) // Ensure path exists
      val success = mockRetryCopy.apply(dummyHdfsSourcePath, dummyLocalDestPath)
      if (success) {
        logger.info(s"Files copied successfully from $dummyHdfsSourcePath to $dummyLocalDestPath")
      } else {
        logger.error(s"Failed to copy files from $dummyHdfsSourcePath to $dummyLocalDestPath after maxRetries retries.")
        throw new RuntimeException(s"Failed to copy files from: $dummyHdfsSourcePath to $dummyLocalDestPath after maxRetries retries")
      }
      success
    }

    assert(exception.getMessage.contains("Failed to copy files"))
    verify(mockRetryCopy).apply(dummyHdfsSourcePath, dummyLocalDestPath)
  }


test("ensureLocalPathExists should do nothing if directory already exists") {
    // Mocking the File class
    val mockFile = mock[File]

    // Dummy path
    val dummyPath = "/mock/local/existing_dir"

    // Stubbing behavior
    when(mockFile.exists()).thenReturn(true)

    // Calling the function
    val result = {
      if (!mockFile.exists()) {
        val created = mockFile.mkdirs()
        if (created) {
          logger.info(s"Successfully created local directory: $dummyPath")
        } else {
          logger.error(s"Failed to create local directory: $dummyPath")
          throw new RuntimeException(s"Failed to create local directory: $dummyPath")
        }
      } else {
        logger.info(s"Local directory already exists: $dummyPath")
      }
    }

    // Assert: Ensure no exception is thrown
    assert(result == ())
    verify(mockFile).exists()
    verify(mockFile, never()).mkdirs()
  }

  test("ensureLocalPathExists should create directory if it does not exist") {
    // Mocking the File class
    val mockFile = mock[File]

    // Dummy path
    val dummyPath = "/mock/local/new_dir"

    // Stubbing behavior
    when(mockFile.exists()).thenReturn(false)
    when(mockFile.mkdirs()).thenReturn(true)

    // Calling the function
    val result = {
      if (!mockFile.exists()) {
        val created = mockFile.mkdirs()
        if (created) {
          logger.info(s"Successfully created local directory: $dummyPath")
        } else {
          logger.error(s"Failed to create local directory: $dummyPath")
          throw new RuntimeException(s"Failed to create local directory: $dummyPath")
        }
      } else {
        logger.info(s"Local directory already exists: $dummyPath")
      }
    }

    // Assert: Ensure directory creation was attempted
    assert(result == ())
    verify(mockFile).exists()
    verify(mockFile).mkdirs()
  }

  test("ensureLocalPathExists should throw RuntimeException if directory creation fails") {
    // Mocking the File class
    val mockFile = mock[File]

    // Dummy path
    val dummyPath = "/mock/local/failed_dir"

    // Stubbing behavior
    when(mockFile.exists()).thenReturn(false)
    when(mockFile.mkdirs()).thenReturn(false)

    // Verify that the exception is thrown
    val exception = intercept[RuntimeException] {
      if (!mockFile.exists()) {
        val created = mockFile.mkdirs()
        if (created) {
          logger.info(s"Successfully created local directory: $dummyPath")
        } else {
          logger.error(s"Failed to create local directory: $dummyPath")
          throw new RuntimeException(s"Failed to create local directory: $dummyPath")
        }
      } else {
        logger.info(s"Local directory already exists: $dummyPath")
      }
    }

    assert(exception.getMessage.contains("Failed to create local directory"))
    verify(mockFile).exists()
    verify(mockFile).mkdirs()
  }
 test("retryCopy should return true if attemptCopy succeeds on the first try") {
    // Mock dependencies
    val mockAttemptCopy = mock[Function2[String, String, Boolean]]
    val mockAttemptDelete = mock[Function1[String, Unit]]
    val mockRetryWithDelay = mock[Function2[Int, Int, Unit]]

    // Dummy paths
    val dummyHdfsSourcePath = "/mock/hdfs/source"
    val dummyLocalDestPath = "/mock/local/dest"

    // Stubbing behavior
    when(mockAttemptCopy.apply(any[String], any[String])).thenReturn(true)

    // Call the function under test
    var success = false
    var attempt = 0
    var delay = 100 // Example initial delay

    while (attempt < 3 && !success) {
      try {
        success = mockAttemptCopy.apply(dummyHdfsSourcePath, dummyLocalDestPath)
        if (success) {
          mockAttemptDelete.apply(dummyHdfsSourcePath)
        }
      } catch {
        case ex: Exception =>
          println(s"Error during copy attempt ${attempt + 1}: ${ex.getMessage}!")
      }

      if (!success) {
        attempt += 1
        mockRetryWithDelay.apply(attempt, delay)
        delay = delay * 2 // Exponential backoff
      }
    }

    // Assertions
    assert(success)
    verify(mockAttemptCopy).apply(dummyHdfsSourcePath, dummyLocalDestPath)
    verify(mockAttemptDelete).apply(dummyHdfsSourcePath)
    verify(mockRetryWithDelay, never()).apply(any[Int], any[Int]) // Should not retry if first attempt succeeds
  }

  test("retryCopy should retry up to maxRetries if attemptCopy fails") {
    // Mock dependencies
    val mockAttemptCopy = mock[Function2[String, String, Boolean]]
    val mockAttemptDelete = mock[Function1[String, Unit]]
    val mockRetryWithDelay = mock[Function2[Int, Int, Unit]]

    // Dummy paths
    val dummyHdfsSourcePath = "/mock/hdfs/source"
    val dummyLocalDestPath = "/mock/local/dest"

    // Stubbing behavior to fail first two attempts and succeed on third
    when(mockAttemptCopy.apply(any[String], any[String]))
      .thenReturn(false, false, true)

    // Call the function under test
    var success = false
    var attempt = 0
    var delay = 100 // Example initial delay

    while (attempt < 3 && !success) {
      try {
        success = mockAttemptCopy.apply(dummyHdfsSourcePath, dummyLocalDestPath)
        if (success) {
          mockAttemptDelete.apply(dummyHdfsSourcePath)
        }
      } catch {
        case ex: Exception =>
          println(s"Error during copy attempt ${attempt + 1}: ${ex.getMessage}!")
      }

      if (!success) {
        attempt += 1
        mockRetryWithDelay.apply(attempt, delay)
        delay = delay * 2 // Exponential backoff
      }
    }

    // Assertions
    assert(success)
    verify(mockAttemptCopy, times(3)).apply(dummyHdfsSourcePath, dummyLocalDestPath)
    verify(mockAttemptDelete).apply(dummyHdfsSourcePath)
    verify(mockRetryWithDelay, times(2)).apply(any[Int], any[Int]) // Should retry twice before succeeding
  }

  test("retryCopy should return false after maxRetries if all attempts fail") {
    // Mock dependencies
    val mockAttemptCopy = mock[Function2[String, String, Boolean]]
    val mockAttemptDelete = mock[Function1[String, Unit]]
    val mockRetryWithDelay = mock[Function2[Int, Int, Unit]]

    // Dummy paths
    val dummyHdfsSourcePath = "/mock/hdfs/source"
    val dummyLocalDestPath = "/mock/local/dest"

    // Stubbing behavior to always fail
    when(mockAttemptCopy.apply(any[String], any[String])).thenReturn(false)

    // Call the function under test
    var success = false
    var attempt = 0
    var delay = 100 // Example initial delay

    while (attempt < 3 && !success) {
      try {
        success = mockAttemptCopy.apply(dummyHdfsSourcePath, dummyLocalDestPath)
        if (success) {
          mockAttemptDelete.apply(dummyHdfsSourcePath)
        }
      } catch {
        case ex: Exception =>
          println(s"Error during copy attempt ${attempt + 1}: ${ex.getMessage}!")
      }

      if (!success) {
        attempt += 1
        mockRetryWithDelay.apply(attempt, delay)
        delay = delay * 2 // Exponential backoff
      }
    }

    // Assertions
    assert(!success)
    verify(mockAttemptCopy, times(3)).apply(dummyHdfsSourcePath, dummyLocalDestPath)
    verify(mockAttemptDelete, never()).apply(any[String]) // Fixed `never()` usage
    verify(mockRetryWithDelay, times(3)).apply(any[Int], any[Int]) // Should retry maxRetries times
  }

}
